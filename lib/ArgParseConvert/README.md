# ArgParseConvert

[GitHub repository.](https://github.com/JasperBraun/ArgParseConvert.git)

[GitHub Pages.](https://jasperbraun.github.io/ArgParseConvert/doxygen/html/index.html)

Yet another argument parsing library designed mainly for personal use. This
library provides facilities to configure positional, keyword and flag
parameters, parse command-line style argument lists and configuration files,
convert arguments to values of the respective parameter's types, and generate a
formatted help-string for viewing in a shell window.

* [Installation](#installation)
* [Overview](#overview)
* [Quick example](#quick-example)

## Installation

***Prerequisites:***
* C++17
* cmake version 3.0 or higher
* git (optional)

***To build binary:***
1. Download or clone into desired directory.
2. On command line `cd` into the directory.
3. Execute `mkdir build && cd build && cmake .. && make`.
4. Done! The binary library file (`libarg_parse_convert.a`) is in the build
   directory.

***To include in cmake project:***
1. Download or clone into desired directory in project tree.
2. In the Parent directory's `CMakeList.txt` file, add the cloned directory as
   subdirectory (using `add_subdirectory`).
3. Link the library target `arg_parse_convert` to all targets which use it, in
   the source code include `arg_parse_convert.h`, and add the
   `ArgParseConvert/include` directory to the target's include directories
   (using `target_include_directories`).

***Unit tests:***
Unit tests are included and compiled when in debug mode. After building, they
can be run using `ctest`. To change when unit tests are built, the top-level
CMakeList.txt must be changed appropriately.

## Overview

For installation instructions, see [Installation](#installation). For a usage
example to copy-paste and modify as needed, see [Quick example](#quick-example).

The ArgParse convert library essentially consists of four components:
* The `ParameterMap` and `Parameter` classes offer methods to configure and
  register various parameters for which arguments are parsed.
* The `ParseArgs` and `ParseFile` functions parse command-line style arguments
  or configuration files as specified by a `ParameterMap` object.
* The `ArgumentMap` class stores configurations of parameters in the form of a
  `ParameterMap` object together with their assigned arguments, and allows for
  retrieval of the parameter values.
* The `FormattedHelpString` function can be used to generate a help-string from
  the various settings specified for the parameters contained in a
  `ParameterMap` object.

These entities are designed to be used as follows:
1. Register various `Parameter` objects in a `ParameterMap` object, using the
   `()` operator of `ParameterMap` and the factory functions of `Parameter`.
2. Create an `ArgumentMap` object from the `ParameterMap` object.
3. Store arguments for the various parameters in the `ArgumentMap` from a
   command-line style list of arguments via `ParseArgs`, or from a configuration
   file via `ParseFile`.
4. Retrieve values of parameters using the `GetValue` and `GetAllValues` methods
   of the `ArgumentMap`.
5. If desired, generate a help-string using `FormattedHelpString`.

An overview of the main aspects of each of these classes and functions is
provided here. For more detailed information on how to use each of the classes
and functinos, see [Reference](whoops).

**Parameter class template***

Parameters are instantiations of the `Parameter` class template. The template
parameter defines the type that the parameter values should take. Creation of a
`Parameter` object occurs via its factory methods:
* `Parameter<bool>::Flag` to create a *flag*.
* `Parameter<T>::Keyword` to create a *keyword parameter* of type
  `T`.
* `Parameter<T>::Positional` to create a *positional parameter* of type `T`.

*Keyword parameters* and *positional parameters* require the specification of a
conversion function, which determines how string arguments are interpreted. The
conversion function for a parameter of type `T` must be an object of the form:
```
std::function<T(const std::string&)>
```

The `AddDefault` and `SetDefault` function members can be used to configure
default arguments for the parameter. Function members `MinArgs` and `MaxArgs`
can be used to restrict the number of arguments a parameter takes. The function
members `Description` and `Placeholder` can be used to customize how a
`Parameter` object is displayed in the help-string generated by
`FormattedHelpString`.

**ParameterMap class**

The configuration of various parameters, as well as their conversion functions
can be stored in a `ParameterMap` object using its `()` operator. A
`ParameterMap` object simply organizes the parameters for the advantage of
`ParseArgs`, `ParseFile` and `FormattedHelpString`.

**ArgumentMap class**

An `ArgumentMap` object contains a `ParameterMap` instance to determine the
settings of the parameters whose arguments it stores. Parameter values can be
obtained using the `GetValue` and `GetAllValues` function members. The member
`IsSet` tests whether a flag was set. Default arguments can be assigned using
the `SetDefaultArguments` function member. Parameters which did not receive
enough arguments can be obtained using the `GetUnfilledParameters` function
member.

**ParseArgs and ParseFile functions**

`ParseArgs` takes command-line style argument lists (`argc`, `argv`) together
with an `ArgumentMap` object and stores the various arguments for appropriate
parameters in the `ArgumentMap`. `ParseFile` takes an input stream and
interprets it as a configuration file assigning arguments to approriate
parameters in the `ArgumentMap` object.

Both functions return a list of arguments for which no appropriate parameters
were found. If some arguments were already assigned to parameters in the
`ArgumentMap`, then any parsed arguments that would usually be assigned to those
parameters are included in the return value, instead.

**FormattedHelpString function**

`FormattedHelpString` is designed to automate the generation of help a string.
The help string is meant to look like the types of help-strings produced by
typical command-line programs when passed the `--help` or `-h` flag. The width
and indentations can be customized by specifying its parameters, instead of
using their default values.

## Quick example

`command`'s `main.cc` file:
```cpp
#include <iostream>
#include <fstream>
#include <string>

#include "arg_parse_convert.h"

// Alternatively, write this function in a separate file and include it.
arg_parse_convert::ParameterMap InitParameters() {
  arg_parse_convert::ParameterMap parameters;
  // Chain `operator()` to add parameters.
  // Placement of parentheses and semi-colon is important.
  // Use `Parameter` factory functions.
  parameters(arg_parse_convert::Parameter<int>::Positional(
                 arg_parse_convert::converters::stoi,
                 "foo", 0)
             .Description("Positional parameter foo description."))

            (arg_parse_convert::Parameter<std::string>::Keyword(
                 arg_parse_convert::converters::StringIdentity,
                 {"c", "config", "configuration-file"})
             .Description("Keyword parameter description. Long description"
                          " which spans multiple lines. Parameter requires lots"
                          " of explaining."))

            (arg_parse_convert::Parameter<bool>::Flag({"h", "help"})
             .Description("Print this help message and exit."));

            // Add more arguments.
  return parameters;
}

int main(int argc, char** argv) {
  std::vector<std::string> additional_arguments;
  try {
    arg_parse_convert::ParameterMap parameters{InitParameters()};
    arg_parse_convert::ArgumentMap arguments{std::move(parameters)};
    additional_arguments = arg_parse_convert::ParseArgs(argc, argv, arguments);

    if (!additional_arguments.empty()) {
      // Some arguments couldn't be assiged to parameters.
      std::cerr << "Invalid argument: " << additional_arguments.at(0)
                << std::endl;
      return 1;
    } else if (arguments.IsSet("help")) {
      std::cout << arg_parse_convert::FormattedHelpString(arguments.Parameters())
                << std::endl;
      return 0;
    } else if (arguments.HasArgument("configuration-file")) {
      std::ifstream ifs{arguments.GetValue("configuration-file")};
      if (ifs.is_open()) {
        additional_arguments = arg_parse_convert::ParseFile(&ifs, arguments);
      } else {
        std::cerr << "Unable to open configuration file: "
                  << arguments.GetValue("configuration-file") << std::endl;
        return 1;
      }

      if (!additional_arguments.empty()) {
        // Some arguments couldn't be assiged to parameters.
        std::cerr << "Invalid argument: " << additional_arguments.at(0)
                  << std::endl;
        return 1;
      }
    }
  } catch (const arg_parse_convert::exceptions::BaseException& e) {
    // Handle exception
  } catch (const std::exception& e) {
    // Handle exception
  }
  // Do work here.
  // Access parsed parameter values using methods `GetValue` and `GetAllValues`.
  return 0;
}
```

Executing `command 1 2 3` will lead to the following behavior:
```cpp
arguments.GetAllValues("foo") == std::vector<int>{1, 2, 3} // true
arguments.GetValue("foo") == 1 // true
arguments.GetValue("foo", 1) == 2 //true
arguments.GetValue("foo", 2) == 3 //true
arguments.GetValue("foo", 3) // throws exception
```

Executing `command -c config_file.config`, where `config_file.config` contains:
```
# Some description of foo.
# foo is a positional parameter.

foo=1 2 3

```
leads to the same behavior.

Executing `command -h` or `command --help` will print the following help
message:
```
Optional positional parameters:
    foo
        Positional parameter foo description.

Optional keyword parameters:
    -c, --config, --configuration-file <ARG>
        Keyword parameter description. Long description which spans multiple
        lines. Parameter requires lots of explaining.

Flags:
    -h, --help
        Print this help message and exit.
```